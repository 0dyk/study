### [목차](../readme.md)

### [37회 기출](https://yunamom.tistory.com/321)

- (-20)

1. (-1)

- 도메인 : 속성에서 값이 가질 수 있는 허용밤위
  - 릴레이션의 속성 값이 가질 수 있는 허용된 값의 범위
  - 속성명과 도메인명은 항상 동일할 필요는 없다.
  - 모든 속성들의 도메인은 원자값 이어야 한다.
- 카디날리티 : 튜플(행) 수 = 인스턴스의 수
  - 중복도가 낮다 -> 카디널리티가 높다.(주민번호)

2. (-2)
   외래키는 주 릴레이션을 참조하는 키

3. (-3)

- 슈퍼/서브 타입 데이터 모델의 변환타입
  - One To One Type
    - 슈퍼타입과 서브타입을 개별 테이블로 도출한다.
    - 테이블의 수가 많아서 조인이 많이 발생하고 관리가 어렵다.
  - Plus Type
    - 슈퍼타입과 서브타입 테이블로 도출
    - 조인이 발생하고 관리가 어렵다
  - Single Type
    - 슈퍼타입과 서브타입을 하나의 테이블로 도출
    - 조인성능이 좋고 관리가 편리하지만 IO 성능이 나쁘다.

4.

- DB 특징 : 추상화, 단순화, 명확성

5.

6.

- 속성의 종류
  - 기본속성 : 비즈니스 프로세스에서 도출되는 본래의 속성(회원ID)
  - 설계속성 : 데이터 모델링 과정에서 발생되는 속성(상품코드)
  - 파생속성 : 다른 속성에 의해서 만들어지는 속성(합계)

7. (-4)

- 식별자 관계
  - 부모 테이블의 기본키 또는 유니크 키를 자식 테이블이 자신의 키본키로 사용하는 관계(실선 표현, 강한 연결관계)
- 비식별자 관계
  - 부모 테이블의 기본키 또는 유니크 키를 자신의 기본키로 사용하지 않고, 외래 키로 사용하는 관계(점선 표현, 약한 연결관계)

8.

9. (-5)

- 성능을 고려한 데이터모델링 순서
  - 데이터모델링을 할 때 정규화를 정확하게 수행
  - 데이터베이스 용량산정 수행
  - 데이터베이스에 발생되는 트랜잭션 유형 파악
  - 용량과 트랜잭션의 유형에 따라 반정규화 수행
  - 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 수행
  - 성능관점에서 데이터 모델 검증

10.

11. (-6)

- 해시조인
  - 두 개의 테이블 간에 조인을 할 떄 범위검색이 아닌 동등조인에 적합한 방식
  - 작은 테이블을 먼저 읽어서 Hash Area에 해시 테이블을 생성하는 방법
  - 수행 빈도가 낮고 수행시간이 오래 걸리는 대용량 테이블에 대한 조인에 유용
- 온라인 트랜잭션 처리에는 적은 데이터를 조인할 떄 유리한 구조인 Nested Loop 방식이 유용하다.

12.

- Nested Loop Join
  - 좁은 범위에 유리
- Sort Merge Join
  - 해당 테이블에 인덱스가 없을 때 수행
- Hash Join
  - 위의 두 조인의 문제점을 해결

13. (-7)

- 부서별 합계(소계) + 전체합계 : ROLLUP

14. (-8)

- MERGE INTO
  - 특정 키에 대해서 레코드가 있을 때에 수정사항에 대해서 UPDATE
  - 레코드가 없으면 새롭게 INSERT 하는 구문
  - DELETE 절은 갱신된 값을 기준으로

15.

- 카테시안 곱
  - M:N에서 join key가 없으면 카테시안 곱 발생

16. (-9)

- START WITH ~ : ~인 행부터 시작
- CONNECT BY 계층형 조회
- WHERE

17.

- NVL : (MGR, 0) : MGR이 NULL이면 0
- NVL2 : (MGR, 1, 0) : NULL이 아니면 1, NULL이면 0
- NULLIF : (exp1, exp2) : exp1 = exp2면 NULL 아니면 exp1 반환
- COALESCE : (NULL, 2, 3) NULL이 아닌 첫 번째 컬럼의 값 반환

18.

19.

- 집계 함수에서 NULL값을 제외하고 연산을 수행함.

20.

21.

22. (-10)

- 윈도우 함수
  - ROWS : 물리적인 행 단위
  - RANGE : 논리적인 행 집합
  - CURRENT ROW : 현재 행
  - UNBOUNDED PRECENDING : 첫 번쨰 행
  - UNBOUNDED FOLLOWING : 마지막 행
  - [위치] PRECEDING : [위치] 이전 행
  - [위치] FOLLOWING : [위치] 다음 행

23.

24. (-11)

- PL/SQL
  - Block구조, 각 기능별로 모듈화가 가능하다.
  - 변수, 상수 등을 선언하여 SQL문장 간 값을 교환 한다.
  - IF, LOOP 등의 절차형 언어를 사용하여 절차적인 프로그램이 가능하도록 한다.
  - DBMS 정의 에러나 사용자 정의 에러를 정의하여 사용할 수 있다.
  - PL/SQL은 Oracle에 내장되어 있으므로 Orace과 PL/SQL을 지원하는 어떤 서버로도 프로그램을 옮길 수 있다.
  - PL/SQL은 응용 프로그램의 성능을 향상시킨다.
  - PL/SQL은 여러 SQL문장을 Block으로 묶고 한번에 Block 전부를 서버로 보내기 떄문에 통신량을 줄일 수 있다.
  - DECLARE, BEGIN ~ END는 필수이지만, EXCEPTION은 필수가 아니다.

25.

- DECODE(값, 조건1, 결과1, default_result)
  - 값이 조건1과 같으면 결과1 반환, 어느 조건에도 해당하지 않으면 default_result 반환, 생략한다면 NULL을 반환

26.

27.

28. (-12)

- GROUP BY와 WINDOW FUNCTION을 같이 쓰면 partition by 대체 가능

29. (-13)

- NOT IN문 서브쿼리의 결과 중에 NULL이 포함되는 경우 데이터가 출력되지 않는다.

30.

- IN 문에서 NULL은 비교에서 제외된다.

31. (-14)

- '%'나 '\_'등과 같은 특수문자를 검색하기 위해서는 ESCAPE를 사용해야한다.
- 아무 특수문자나 사용해도 된다.

32.
33. (-15)

- GRANT [권한] ON [테이블명] TO [유저명]

34. 35.(-16)

- WHERE EXISTS()

  - 괄호 안에 서브 쿼리만 들어갈 수 있음. 특정 값 X
  - 메인쿼리 -> 서브쿼리 순으로 처리
  - 서브쿼리 결과가 존재하는지만 확인
  - NULL에 대해 TRUE 리턴

- - WHERE IN()
  - 괄호 아넹 특정 값, 서브 쿼리 들어갈 수 있음
  - 서브 쿼리 -> 메인 쿼리 순으로 처리
  - NULL에 대해 FALSE 리턴, NOT IN 사용시 NVL로 NULL체크 필요

36. (-17)

- 위에서 아래로 일겅 내려간다.
- 같은 들여 쓰기가 존재한다면 위 -> 아래로 읽는다.
- 하위스템이 존재한다면 하위 스탭부터 읽는다.

37.

- UNION 및 UNION ALL을 사용할 때 나오는 SQL문은 칼럼 수와 데이터 타입이 완전 일치해야함

38.

39.

- FIRST_VALUE : 파티션에서 가장 처음에 나오는 값
- LAST_VALUE : 파티션에서 가장 나중에 나오는 값
- LAG : 이전에 행을 가지고 온다.
- LEAD : 윈도우에서 특정 위치의 행을 가지고 온다.(기본값 1)

40.
41.

- 트랜잭션의 특징
  - 원자성 : 모두 반영 or 전혀 반영되지 X
  - 일관성 : 처리 결과는 항상 일관성이 있어야 한다.
  - 고립성 : 둘 이상의 트랜잭션이 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
  - 지속성 : 결과는 영구적으로 반영

42.

- CROSS JOIN
  - 상호 조인, 한 쪽 테이블의 모든 행들과 다른 테이블의 모든 행을 조인
  - 카테시안 곱
  - WHERE 절에 JOIN 조건 추가 가능
- NATURAL JOIN
  - 동일한 컬럼을 내부적으로 찾게 되듬로 테이블 별칭을 주면 오류 발생
  - WHERE 절에 JOIN조건 불가

43.

ㅡㅡㅡㅡㅡ 주관식 ㅡㅡㅡㅡㅡ

44. (-18)

- GROUPING SETS(B.GRADE, (B.GRADE, A.STUDENTNO))

45. (-19)

- NULLS FIRST : 정렬하고자 하는 NULL 데이터들을 데이터 앞에 나오게
- NULLS LAST : 정렬하고자 하는 NULL 데이터를 데이터 뒤에 나오게
- Default : NULLS FIRST

46.

- 왼쪽 테이블의 존재하는 값이 조회됨(오른쪽 NULL로)
- LEFT OUTER JOIN

47.
48.
49. (-20)

- NTILE(n) : 데이터를 n등분 한다.

50.

- RANGE : 현재 행의 데이터 값을 기준으로 앞뒤 데이터 값의 범위를 표시
