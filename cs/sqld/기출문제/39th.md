### [목차](../readme.md)

### 39회 기출(-13)

1.

- 수직 분할은 디스크 I/O를 줄일 수 있는 방법

2.

- 제1정규화 : 테이블의 속성 하나는 하나의 속성값만을 가져야 한다.
- 제2정규화 : 기본키 중에 특정 컬럼에만 종속된 컬럼이 존재할 경우 테이블을 분해한다.
- 제3정규화 : 제 2정규형을 만족하는 상태에서 이행 함수 종속을 제거하는 정규화

3.

- One To One Type : 개별 테이블
- Plus Type : 수퍼 + 서브 타입 테이블
- Single Type : 하나의 테이블

4. (-1)

- 도메인은 속성이 가질 수 있는 값의 범위

  5.(-2)

- 제3정규화는 주식별자를 제외한 컬럼간에 종속성을 확인해서 종속성이 있으면 분할하는 과정

6.

- 독립엔티티 : 현실세계에 존재하는 엔터티
- 업무중심 엔터티 : Transaction이 실행되면서 발생하는 엔터티
- 종속 엔터티 : 주로 1 정규화로 인해 관련 중심엔터티로 분리된 엔터티
- 교차 엔터티 : M:N의 관게를 해소하려는 목적으로 만들어지는 엔터티

- 유형 엔터티 : 업무에서 도출되며 지속적으로 사용되는 엔터티
- 개념 엔터티 : 개념적으로 사용되는 엔터티
- 사건 엔터티 : 비즈니스 프로세스를 실행하면서 생성되는 엔터티

- 기본 엔터티 : 다른 엔터티로부터 영향을 받지 않고 독립적으로 생성되는 엔터티키 엔터티
- 중심 엔터티 : 기본 엔터티로부터 발생되고 행위 엔터티를 생성하는 엔터티
- 행위 엔터티 : 2개 이상의 엔터티로부터 발생하는 엔터티

7.

- 식별관계 : 부모 테이브르이 기본키 또는 유니크 키를 자식 테이블이 기본키로 사용하는 관계(실선)
- 비식별관계 : 부모 테이블의 기본키 또는 유니크 키를 자신의 기본키로 사용하지 않고, 외래 키로 사용하는 관계(점선)

8.

- ERD 작성 절차
  - 엔터티를 그린다
  - 엔터티를 적절하게 배치한다.
  - 엔터티 간에 관계를 설정한다.
  - 관계명을 기술한다.
  - 관계의 참여도를 기술한다.
  - 관계의 필수 여부를 기술한다.

9.

- 주식별자 : 각 행을 구분할 수 있는 구분자
- 보조식별자 :

- 내부식별자 : 엔터티 내부에서 스스로 만들어지는 식별자
- 외부식별자 :

- 단일식별자 : 하나의 속성으로 구성된 식별자
- 복합실별자 :

- 본질식별자 : 업무에 의해 만들어지는 식별자
- 인조식별자 :

10.

11.

- RANK() : 중복값은 중복 등수, 건너뜀 / 1,1,3,4위
- DENSE_RANK() : 중복갑은 중복 등수, 안 건너뜀 / 1,1,2,2위
- ROW_NUMBER() : 중복값이 있어도 고유 등수 부여 / 1,2,3,4위

12.

13. (-3)

- CREATE index [인덱스이름] on [테이블이름] (컬럼명);
- 흠...

14.

- UNION ALL : 전부 합침
- MINYS : 차집합 -> 중복 제거됨?

15.

- Sort Merge Join은 테이블의 인덱스가 없을 떄 수행
- 테이블을 정렬한 후에 테이블을 병합하면서 조인

16.

- CONNECT_BY_ROOT : 최항위 로우를 반환하는 연산자
- CONNECT_BY_ISLEAF : 최하의 자식 로우이면 1, 아니면 0을 반환하는 의사 컬럼
- 정렬할 떄 계층형 구조까지 보존하려면 ORDER SIBLINGS BY절을 사용해야 한다.

17.

18.

- ROLLUP : 전체합계와 소그룹 간의 소계를 계산하는 함수
- CUBE : 제시한 칼럼에 대해서 결합 가능한 모든 집계를 계산
- GROUPING SET : 원하는 부분의 소계만 계산할 수 있는 함수 ()는 전체를 계산

19.

20.

- char : 고정형
- varchar : ms-sql, MySQL(MariaDB)에서 사용, 문자열 255길이
- varchar2 : Oracle에서 사용 4000byte(한글 2000, 영문 4000)저장 가능

21. (-4)

- ORDER SIBLING BY를 수행하면 전체 테이블이 아니라 계층형으로 된 데이터값(특정 칼럼) 기준으로 정렬
- CONNECT BY PRIOR ID = PARENT_ID : 부모 ID를 기준으로 자식 ID를 검색 : 순방향

22.

- UNIQUE SCAN : 유일한 값 찾기 \*한개의 행
- RANGE SCAN : 어떠한 조건에서 한 범위를 찾기
- FULL SCAN : 전체 데이터 \*전체 행

23.

24.

- VARCHAR은 비교 시 길이가 다른 경우 서로 다른 내용으로 판단
- CHAR은 길이가 다른 경우 짧은 쪽에 스페이스를 추가하여 같은 값으로 판단한다.
- 문자형과 숫자형을 비교 시 문자형을 숫자형으로 묵시적 변환하여 비교
- 연산자 실행 순서는 괄호, NOT, 비교연산자, AND, OR 순

25. (-5)

26. (-6)

27.

- VIEW : 가상테이블
  - 독립성 : 테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 된다.
  - 편리성 : 복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성할 수 있다.
  - 보안성 : 숨기고 싶은 정보가 존재하는 경우, 뷰를 생성할 때 해당 컬럼을 빼고 생성하여 정보를 숨기고 있다.

28.

29.

30.

- SUB QUERY
  - SERVICE 서브쿼리
  - EARLY FILTER형 서브쿼리
    - 데이터 필터링 역할
  - CORRECLATED 서브쿼리
    - 상관관계가 있는 서브 쿼리
    - 내부 쿼리가 외부 쿼리에서 얻은 정보에 의지해 실행
  - LOOPING 서브쿼리

31.

32.

33.

- DDL
  - ALTER TABLE [테이블명] ADD COLUMN [컬럼명] [조건]
  - ALTER TABLE [테이블명] MODIFY COLUMN [컬럼명] [조건]
  - ALTER TABLE [테이블명] CHANGE COLUMN [컬럼명] [변경할컬럼명] [조건]
  - ALTER TABLE [테이블명] DROP COLUMN [컬럼명]
  - ALTER TABLE [테이블명] RENAME [변경할테이블명]

34.

- NULL

35. (-7)

- START WITH

- CONNECT BY
  - PRIOR [다음 행의 값] = [현재 행의 값]

36.

37. (-8)

- SUB QUERY
  - 서브쿼리에서는 정렬을 수행하기 위해서 내부에 ORDER BY를 사용하지 못한다.
  - 메인 쿼리를 작성할 떄 서브쿼리에 있는 칼럼을 자유롭게 사용할 수 없다.
  - 여러 개의 행을 되돌리는 서브쿼리는 다중행 연산자를 사용해야한다.
  - EXIST는 TRUE와 FALSE만 되돌린다.

38. (-9)

- 내일 날짜 구하기
  - TO_CHAR(sysdate + 1, 'YYYYMMDD')

39.

- PL/SQL

  - CURSOR 선언 -> OPEN -> FETCH -> CLOSE

- CURSOR(DB의 연결 포인트, 연결점)

  - SQL 커서는 Oracle 서버에서 할당한 전용 메모리 영역에 대한 포인터이다.
  - 질의의 결과로 얻어진 여러 행이 저장된 메모리상의 위치.
  - 커서는 SELECT 문의 결과 집합을 처리하는데 사용된다.

- 명시적 커서 : 사용자가 직접 정의해서 사용하는 커서
- 묵시적(암시적) 커서 : 데이터베이스가 내부적으로 사용하는 커서

40.

41.

- 분산 데이터베이스
  - 데이터베이스 신뢰성과 가용성이 높다.
  - 병렬 처리를 수행하기 떄문에 빠른 응답이 가능
  - 시스템 용량 확장이 쉽다.
  - 관리와 통제가 어렵다.
  - 보안관리가 어렵다.
  - 데이터 무결성 관리가 어렵다.
  - 데이터베이스 설계가 복잡함

42.

- HASH JOIN
  - 조인 컬럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있다.
  - 해시 함수를 이용하여 조인을 수행하기 때문에 '='로 수행하는 조인으로 동등 조건에만 사용가능
  - 해시 함수가 적용될 떄 동일한 값을 항상 같은 값으로 해싱됨이 보장된다.
  - HASH JOIN 작업을 수행하기 위해 해시 테이블을 메모리에 생성해야 한다.
  - 메모리에 적재할 수 있는 영역의 크기보다 커지면 임시 영역(디스크)에 해시 테이블을 저장한다.
  - HASH JOIN을 할 때는 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것이 좋다.
  - 선행 테이블을 Build input이라 하며, 후행 테이블을 Prove input이라 한다.

43.

44.

- ROUND : 반올림, 두번째 인자 자리까지
- FLOOR : 정수로 내림
- TRUNC : 소수점 버림
- CEIL : 정수로 올림

45. (-11)

- ROLE : 데이터베이스에서 OBJECT(테이블, 프로시저, 뷰)등의 권한을 묶어서 관리할 수 있다.

46. (-12)

- DDL 명령어를 입력하는 순간. 명령어에 해당하는 작업이 즉시(AUTO COMMIT) 완료

47.

48.

49.

50. (-13)

- EXISTS : 하위 쿼리에 레코드가 있는지 테스트 하는 데 사용된다.
  - 하위 커리가 하나 이상의 레코드를 반환하는 경우 TRUE, 아니면 FALSE
  - 속도가 빠르다.
